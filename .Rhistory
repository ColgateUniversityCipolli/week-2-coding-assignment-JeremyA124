mid.points <- (left.points+right.points)/2
left.points <- a + 0:99*(delta.x)
(left.area <- sum(delta.x*(integrand(left.points))))
right.points <- a + 1:100*(delta.x)
(right.area <- sum(delta.x*(integrand(right.points))))
mid.points <- (left.points+right.points)/2
(mid.area <- sum(delta.x*(integrand(mid.points))))
# Write code for answer here.
trap.points <- a + (1:99*(delta.x))
(trap.area <- sum((delta.x/2)*(integrand(a)+2*integrand(trap.points)+integrand(b))))
# Write code for answer here.
trap.points <- a + (1:99*(delta.x))
(trap.area <- sum((delta.x)*(integrand(a)+2*integrand(trap.points)+integrand(b))))
# Write code for answer here.
trap.points <- a + (1:99*(delta.x))
(trap.area <- sum((b-a/(n.rect*2))*(integrand(a)+2*integrand(trap.points)+integrand(b))))
# Write code for answer here.
trap.points <- a + (1:99*(delta.x))
(trap.area <- sum((b-a/(n.rect*2))*(integrand(a)+2*integrand(trap.points)+integrand(b))))
# Write code for answer here.
trap.points <- a + (1:99*(delta.x))
(trap.area <- sum(((b-a)/(n.rect*2))*(integrand(a)+2*integrand(trap.points)+integrand(b)))))
# Write code for answer here.
trap.points <- a + (1:99*(delta.x))
(trap.area <- sum(((b-a)/(n.rect*2))*(integrand(a)+2*integrand(trap.points)+integrand(b))))
# Write code for answer here.
trap.points <- a + (1:99*(delta.x))
(trap.area <- sum((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b)))))
# Write code for answer here.
trap.points <- a + (1:99*(delta.x))
(trap.area <- sum((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b))))
right.points <- a + 1:100*(delta.x)
(right.area <- sum(delta.x*(integrand(right.points))))
# Write code for answer here.
trap.points <- a + 1:99*(delta.x)
(trap.area <- sum((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b))))
# Write code for answer here.
trap.points <- a + 1:99*(delta.x)
(trap.area <- sum((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b))))
a <- 0
b <- 2
n.rect <- 100
(delta.x <- (b-a)/n.rect)
# Write code for answer here.
trap.points <- a + 1:99*(delta.x)
(trap.area <- sum((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b))))
integrand <- function(x){
f <- 7 - 2 * x^2
return(f)
}
integrand <- function(x){
f <- 7 - 2 * x^2
return(f)
}
# Write code for answer here.
trap.points <- a + 1:99*(delta.x)
(trap.area <- sum((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b))))
(trap.area <- sum(((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b))))
(trap.area <- sum(((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b))))
# Write code for answer here.
trap.points <- a + 1:99*(delta.x)
(trap.area <- sum(((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b))))
# Write code for answer here.
trap.points <- a + 1:99*(delta.x)
# Write code for answer here.
trap.points <- a + 1:99*(delta.x)
(trap.area <- sum((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b)))
a <- 0
b <- 2
n.rect <- 100
(delta.x <- (b-a)/n.rect)
trap.points <- a + 1:99*(delta.x)
(trap.area <- sum(((delta.x/2)*(integrand(a)+(2*integrand(trap.points))+integrand(b)))
trap.points <- a + 1:99*(delta.x)
trap.area <- sum((delta.x/2)*(integrand(a)+(integrand(trap.points))+integrand(b))
print(trap.area)
print(trap.area)
a <- 0
b <- 2
n.rect <- 100
(delta.x <- (b-a)/n.rect)
trap.points <- a + 1:99*(delta.x)
trap.area <- sum((delta.x/2)*(integrand(a)+(integrand(trap.points))+integrand(b))
trap.area <- sum((delta.x/2)*(integrand(a)+(integrand(trap.points))+integrand(b))
a <- 0
b <- 2
n.rect <- 100
(delta.x <- (b-a)/n.rect)
trap.points <- a + 1:99*(delta.x)
area <- sum((delta.x/2)*(integrand(a)+integrand(trap.points)+integrand(b))
a <- 0
b <- 2
n.rect <- 100
(delta.x <- (b-a)/n.rect)
trap.points <- a + 1:99*(delta.x)
area <- sum((delta.x)*(integrand(a)+integrand(trap.points)+integrand(b))
a <- 0
b <- 2
n.rect <- 100
(delta.x <- (b-a)/n.rect)
a <- 0
b <- 2
n.rect <- 100
(delta.x <- (b-a)/n.rect)
trap.points <- a + 1:99*(delta.x)
area <- sum((delta.x)*(integrand(a)+integrand(trap.points)+integrand(b))
area <- sum((delta.x)*(integrand(a)+integrand(trap.points)+integrand(b)))
integrand <- function(x){
f <- 7 - 2 * x^2
return(f)
}
one = integran(a)
one = integrand(a)
one = integrand(b)
left.points <- a + 0:99*(delta.x)
left.area <- integrand(left.points)
trap.points <- a + 1:99*(delta.x)
area <- sum(delta.x*(integrand(a)+integrand(trap.points)+integrand(b)))
trap.points <- a + 1:99*(delta.x)
area <- sum((delta.x*1/2)*(integrand(a)+integrand(trap.points)+integrand(b)))
print(trap.area)
inty = integrand(trap.points)
inty = integrand(trap.points)*2
area <- sum((delta.x*1/2)*(integrand(a)+inty+integrand(b)))
print(trap.area)
term = delta.x/2
term = delta.x/2
area <- sum(term*(integrand(a)+inty+integrand(b)))
area <- term*sum((integrand(a)+inty+integrand(b)))
term = delta.x/2
area <- term*sum((integrand(a)+inty+integrand(b)))
area <- term*sum((integrand(a)+inty+integrand(b)))-1
test = integrand(b)
left.area[100]
test = integrand(b-0.02)
test = integrand(b)
larea <- (sum(inty)+integrand(b) + integrand(a))
larea <- delta.x*(sum(inty)+integrand(b) + integrand(a))
larea <- delta.x/2*(sum(inty)+integrand(b) + integrand(a))
larea <- (sum(inty)+integrand(b) + integrand(a))
tarea <- sum(integrand(a) + integrand(trap.points)+ integrand(b))
tarea <- sum(integrand(trap.points))+integrand(b)+integrand(a)
tarea <- sum(integrand(trap.points)*2)+integrand(b)+integrand(a)
# Write code for answer here.
trap.points <- a + 1:99*(delta.x)
(trap.area <- (delta.x/2)*(integrand(a)+sum(2*integrand(trap.points))+integrand(b))
integrand <- function(x){
integrand <- function(x){
f <- 7 - 2 * x^2
return(f)
}
\begin{enumerate}
\bibliography{bibliography}
a <- 0
b <- 2
n.rect <- 100
(delta.x <- (b-a)/n.rect)
mid.points <- (left.points+right.points)/2
(mid.area <- sum(delta.x*(integrand(mid.points))))
left.points <- a + 0:99*(delta.x)
right.points <- a + 1:100*(delta.x)
# Write code for answer here.
trap.points <- a + 1:99*(delta.x)
(trap.area <- (delta.x/2)*(integrand(a)+sum(2*integrand(trap.points))+integrand(b))
(trap.area <- (delta.x/2)*(integrand(a)+sum(2*integrand(trap.points))+integrand(b)))
mid.points <- (left.points+right.points)/2
(mid.area <- sum(delta.x*(integrand(mid.points))))
riemann.sums <- function(fnct,                        # function to integrate
a,                           # lower bound of integral
b,                           # upper bound of integral
n.rect,                      # number of  bound of integral
method = "Trapezoidial"){    # method to use (trap by default)
######################################
# Check Input
######################################
if(!is.numeric(a)){ # if a is not numeric
stop("The lower bound of the integral (a) must be numeric.")
}
if(!is.numeric(b)){ # if b is not numeric
stop("The lower bound of the integral (a) must be numeric.")
}
if(!(is.numeric(n.rect)) | (n.rect%%1!=0)){ # if n.rect is not a whole number
stop("The number of rectangles must be a positive whole number.")
}
######################################
# Compute Area
######################################
delta.x = ((b-a)/n.rect)
if(method == "Left"){
left.points <- a + 0:99*(delta.x)
area <- sum(delta.x*(integrand(left.points)))
}else if(method == "Right"){
right.points <- a + 1:100*(delta.x)
area <- sum(delta.x*(integrand(right.points)))
}else if(method == "Midpoint"){
mid.points <- (left.points+right.points)/2
area <- sum(delta.x*(integrand(mid.points)))
}else if(method == "Trapezoidial"){
trap.points <- a + 1:99*(delta.x)
trap.area <- (delta.x/2)*(integrand(a)+sum(2*integrand(trap.points))+integrand(b))
}else{
stop("Please select a valid method (e.g., 'Left', 'Right', 'Midpoint', 'Trapezoidial')")
}
######################################
# Return the area
######################################
return(area)
}
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Trapezodal")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Trapezoidal")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Trapezoidial")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Trapezoidial")
######################################
# Compare to numerical integral
######################################
integrate(f = integrand, # integrate() is an R function
lower = 0,     # that completes numerical
upper = 2)     # integration
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Trapezoidial")
integrand <- function(x){
f <- 7 - 2 * x^2
return(f)
}
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Trapezoidial")
riemann.sums <- function(fnct,                        # function to integrate
a,                           # lower bound of integral
b,                           # upper bound of integral
n.rect,                      # number of  bound of integral
method = "Trapezoidial"){    # method to use (trap by default)
######################################
# Check Input
######################################
if(!is.numeric(a)){ # if a is not numeric
stop("The lower bound of the integral (a) must be numeric.")
}
if(!is.numeric(b)){ # if b is not numeric
stop("The lower bound of the integral (a) must be numeric.")
}
if(!(is.numeric(n.rect)) | (n.rect%%1!=0)){ # if n.rect is not a whole number
stop("The number of rectangles must be a positive whole number.")
}
######################################
# Compute Area
######################################
delta.x = ((b-a)/n.rect)
if(method == "Left"){
left.points <- a + 0:99*(delta.x)
area <- sum(delta.x*(integrand(left.points)))
}else if(method == "Right"){
right.points <- a + 1:100*(delta.x)
area <- sum(delta.x*(integrand(right.points)))
}else if(method == "Midpoint"){
mid.points <- (left.points+right.points)/2
area <- sum(delta.x*(integrand(mid.points)))
}else if(method == "Trapezoidial"){
trap.points <- a + 1:99*(delta.x)
area <- (delta.x/2)*(integrand(a)+sum(2*integrand(trap.points))+integrand(b))
}else{
stop("Please select a valid method (e.g., 'Left', 'Right', 'Midpoint', 'Trapezoidial')")
}
######################################
# Return the area
######################################
return(area)
}
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Trapezoidial")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Midpoint")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Midpoint")
riemann.sums <- function(fnct,                        # function to integrate
a,                           # lower bound of integral
b,                           # upper bound of integral
n.rect,                      # number of  bound of integral
method = "Trapezoidial"){    # method to use (trap by default)
######################################
# Check Input
######################################
if(!is.numeric(a)){ # if a is not numeric
stop("The lower bound of the integral (a) must be numeric.")
}
if(!is.numeric(b)){ # if b is not numeric
stop("The lower bound of the integral (a) must be numeric.")
}
if(!(is.numeric(n.rect)) | (n.rect%%1!=0)){ # if n.rect is not a whole number
stop("The number of rectangles must be a positive whole number.")
}
######################################
# Compute Area
######################################
delta.x = ((b-a)/n.rect)
left.points <- a + 0:99*(delta.x)
right.points <- a + 1:100*(delta.x)
if(method == "Left"){
area <- sum(delta.x*(integrand(left.points)))
}else if(method == "Right"){
area <- sum(delta.x*(integrand(right.points)))
}else if(method == "Midpoint"){
mid.points <- (left.points+right.points)/2
area <- sum(delta.x*(integrand(mid.points)))
}else if(method == "Trapezoidial"){
trap.points <- a + 1:99*(delta.x)
area <- (delta.x/2)*(integrand(a)+sum(2*integrand(trap.points))+integrand(b))
}else{
stop("Please select a valid method (e.g., 'Left', 'Right', 'Midpoint', 'Trapezoidial')")
}
######################################
# Return the area
######################################
return(area)
}
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Midpoint")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Left")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Right")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 10000,
method = "Right")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 10000,
method = "Trapezoidial")
######################################
# Compare to numerical integral
######################################
integrate(f = integrand, # integrate() is an R function
lower = 0,     # that completes numerical
upper = 2)     # integration
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Trapezoidial")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 150,
method = "Trapezoidial")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 150,
method = "Left")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 150,
method = "Trapezoidial")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 90,
method = "Trapezoidial")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Trapezoidial")
######################################
# Compare to numerical integral
######################################
integrate(f = integrand, # integrate() is an R function
lower = 0,     # that completes numerical
upper = 2)     # integration
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100)
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Midpoint")
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100,
method = "Left")
integrand <- function(x){
f <- 7 - 2 * x^2
return(f)
}
a <- 0
b <- 2
n.rect <- 100
(delta.x <- (b-a)/n.rect)
left.points <- a + 0:99*(delta.x)
(left.area <- sum(delta.x*(integrand(left.points))))
######################################
# Test the function
######################################
riemann.sums(fnct = integrand,
a = 0,
b = 2,
n.rect = 100)
